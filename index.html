<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Minecraft Survival - Mining Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path d="M9 0h2v20H9zM0 9h20v2H0z" fill="rgba(255,255,255,0.8)"/></svg>') no-repeat center;
            transform: translate(-50%, -50%); pointer-events: none; mix-blend-mode: difference; z-index: 10;
        }
        #ui-container { position: absolute; bottom: 0; width: 100%; pointer-events: none; }
        #hotbar {
            display: flex; justify-content: center; background: rgba(0,0,0,0.5); padding: 5px; gap: 5px;
            pointer-events: auto; width: fit-content; margin: 0 auto 10px auto; border-radius: 5px;
        }
        .slot {
            width: 50px; height: 50px; background: rgba(139, 139, 139, 0.8); border: 3px solid #373737;
            display: flex; justify-content: center; align-items: center; cursor: pointer; position: relative;
        }
        .slot.active { border-color: white; box-shadow: 0 0 10px white; }
        .slot img { width: 36px; height: 36px; image-rendering: pixelated; }
        .count { position: absolute; bottom: 2px; right: 2px; color: white; font-weight: bold; font-size: 14px; text-shadow: 2px 2px 0 #000; }
        
        #inventory-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 20; justify-content: center; align-items: center;
            flex-direction: column; color: white;
        }
        #inventory-window {
            background: #c6c6c6; padding: 25px; border: 4px solid #555; color: #333;
            display: flex; gap: 30px; box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }
        .grid-container { display: grid; gap: 4px; background: #8b8b8b; padding: 6px; border: 2px solid #fff; border-right-color: #373737; border-bottom-color: #373737; }
        .crafting-section { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 15px; }
        .crafting-arrow { font-size: 32px; font-weight: bold; color: #333; }
        
        #debug { position: absolute; top: 15px; left: 15px; color: white; font-weight: bold; text-shadow: 1px 1px 0 #000; pointer-events: none; line-height: 1.4; }
        #stats { position: absolute; bottom: 85px; left: 50%; transform: translateX(-50%); color: white; pointer-events: none; }
        .heart-container { display: flex; gap: 4px; margin-bottom: 5px; }
        .heart { color: #ff4d4d; font-size: 24px; text-shadow: 2px 2px 0 #000; }

        #mining-progress-container {
            position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%);
            width: 120px; height: 12px; background: rgba(0,0,0,0.5); border: 2px solid #fff;
            display: none;
        }
        #mining-progress-bar { width: 0%; height: 100%; background: #fff; }
    </style>
</head>
<body>

<div id="debug">
    <b>Minecraft Survival</b><br>
    L-Click: Mine/Attack<br>
    R-Click: Place/Interact<br>
    'E': Inventory/Crafting<br>
    '1-9': Select Slot
</div>

<div id="crosshair"></div>
<div id="mining-progress-container"><div id="mining-progress-bar"></div></div>

<div id="stats">
    <div class="heart-container" id="health-row"></div>
</div>

<div id="inventory-screen">
    <h2 style="margin-bottom: 20px; text-shadow: 2px 2px 0 #000;">Survival Inventory</h2>
    <div id="inventory-window">
        <div>
            <h3 style="margin-top:0">Inventory</h3>
            <div id="main-inventory" class="grid-container" style="grid-template-columns: repeat(9, 1fr);"></div>
            <h3 style="margin-bottom:5px">Hotbar</h3>
            <div id="hotbar-inventory" class="grid-container" style="grid-template-columns: repeat(9, 1fr);"></div>
        </div>
        <div class="crafting-section">
            <h3 id="crafting-title" style="margin-top:0">Crafting (3x3)</h3>
            <div id="crafting-grid" class="grid-container"></div>
            <div class="crafting-arrow">➜</div>
            <div id="crafting-result" class="slot" style="background: #8b8b8b; width:64px; height:64px;"></div>
        </div>
    </div>
    <div style="margin-top: 25px; color: #ccc; font-weight: bold;">[Press 'E' to Resume]</div>
</div>

<div id="ui-container">
    <div id="hotbar"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
/**
 * 1. ASSET GENERATION
 */
const TextureGen = {
    cache: {},
    create(name, color, noiseAlpha = 0.1, details = []) {
        if (this.cache[name]) return this.cache[name];
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, 64, 64);
        for(let i=0; i<500; i++) {
            ctx.fillStyle = `rgba(0,0,0,${Math.random() * noiseAlpha})`;
            ctx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
            ctx.fillStyle = `rgba(255,255,255,${Math.random() * noiseAlpha})`;
            ctx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
        }
        details.forEach(d => {
            ctx.fillStyle = d.color;
            if(d.type === 'rect') ctx.fillRect(d.x, d.y, d.w, d.h);
            if(d.type === 'spots') for(let i=0; i<d.count; i++) ctx.fillRect(Math.random()*60, Math.random()*60, d.s, d.s);
        });
        const url = canvas.toDataURL();
        this.cache[name] = url;
        return url;
    }
};

const TEX = {
    grass_top: TextureGen.create('grass_top', '#5cb85c', 0.1, [{type:'spots', count:50, s:2, color:'#4cae4c'}]),
    grass_side: TextureGen.create('grass_side', '#795548', 0.1, [{type:'rect', x:0, y:0, w:64, h:20, color:'#5cb85c'}]),
    dirt: TextureGen.create('dirt', '#795548', 0.15),
    stone: TextureGen.create('stone', '#757575', 0.1),
    wood: TextureGen.create('wood', '#5d4037', 0.1, [{type:'rect', x:10, y:0, w:10, h:64, color:'#4e342e'}, {type:'rect', x:40, y:0, w:10, h:64, color:'#4e342e'}]),
    leaves: TextureGen.create('leaves', '#388e3c', 0.2, [{type:'spots', count:100, s:4, color:'#2e7d32'}]),
    plank: TextureGen.create('plank', '#a1887f', 0.05, [{type:'rect', x:0, y:0, w:64, h:2, color:'#5d4037'}, {type:'rect', x:0, y:32, w:64, h:2, color:'#5d4037'}]),
    cobble: TextureGen.create('cobble', '#616161', 0.2, [{type:'rect', x:5, y:5, w:20, h:20, color:'#757575'}]),
    craft_side: TextureGen.create('craft_side', '#5d4037', 0.1, [{type:'rect', x:10, y:10, w:44, h:44, color:'#8d6e63'}]),
    craft_top: TextureGen.create('craft_top', '#a1887f', 0.1, [{type:'rect', x:10, y:10, w:44, h:2, color:'#333'}, {type:'rect', x:10, y:30, w:44, h:2, color:'#333'}]),
    bed_top: TextureGen.create('bed_top', '#d32f2f', 0.1, [{type:'rect', x:0, y:0, w:64, h:20, color:'#eee'}]),
    wool: TextureGen.create('wool', '#eeeeee', 0.05),
    bedrock: TextureGen.create('bedrock', '#212121', 0.4)
};

const BLOCK = { AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, WOOD: 4, LEAVES: 5, PLANKS: 6, COBBLE: 7, CRAFTING: 8, BED: 9, WOOL: 10, BEDROCK: 99 };

const ITEMS = {
    [BLOCK.GRASS]: { name: "Grass", texture: TEX.grass_side, type: 'block', hardness: 0.6 },
    [BLOCK.DIRT]: { name: "Dirt", texture: TEX.dirt, type: 'block', hardness: 0.5 },
    [BLOCK.STONE]: { name: "Stone", texture: TEX.stone, type: 'block', hardness: 1.5, tool: 'pick', drop: BLOCK.COBBLE },
    [BLOCK.WOOD]: { name: "Log", texture: TEX.wood, type: 'block', hardness: 2.0 },
    [BLOCK.LEAVES]: { name: "Leaves", texture: TEX.leaves, type: 'block', hardness: 0.2 },
    [BLOCK.PLANKS]: { name: "Planks", texture: TEX.plank, type: 'block', hardness: 2.0 },
    [BLOCK.COBBLE]: { name: "Cobble", texture: TEX.cobble, type: 'block', hardness: 2.0, tool: 'pick' },
    [BLOCK.CRAFTING]: { name: "Workbench", texture: TEX.craft_side, type: 'block', hardness: 2.5 },
    [BLOCK.BED]: { name: "Bed", texture: TEX.bed_top, type: 'block', hardness: 0.5 },
    [BLOCK.WOOL]: { name: "Wool", texture: TEX.wool, type: 'block', hardness: 0.8 },
    [BLOCK.BEDROCK]: { name: "Bedrock", texture: TEX.bedrock, type: 'block', hardness: Infinity },
    100: { name: "Stick", texture: TextureGen.create('stick', '#8d6e63', 0, [{type:'rect',x:28,y:10,w:8,h:44,color:'#5d4037'}]), type: 'item' },
    101: { name: "Wood Pick", texture: TextureGen.create('wp','rgba(0,0,0,0)',0,[{type:'rect',x:30,y:30,w:4,h:30,color:'#8d6e63'},{type:'rect',x:10,y:20,w:44,h:8,color:'#a1887f'}]), type: 'tool', toolType: 'pick', efficiency: 3 },
    102: { name: "Wood Sword", texture: TextureGen.create('ws','rgba(0,0,0,0)',0,[{type:'rect',x:30,y:45,w:4,h:15,color:'#8d6e63'},{type:'rect',x:25,y:10,w:14,h:35,color:'#a1887f'}]), type: 'tool', damage: 4 },
    103: { name: "Stone Pick", texture: TextureGen.create('sp','rgba(0,0,0,0)',0,[{type:'rect',x:30,y:30,w:4,h:30,color:'#8d6e63'},{type:'rect',x:10,y:20,w:44,h:8,color:'#757575'}]), type: 'tool', toolType: 'pick', efficiency: 5 },
    104: { name: "Stone Sword", texture: TextureGen.create('ss','rgba(0,0,0,0)',0,[{type:'rect',x:30,y:45,w:4,h:15,color:'#8d6e63'},{type:'rect',x:25,y:10,w:14,h:35,color:'#757575'}]), type: 'tool', damage: 6 }
};

/**
 * 2. PHYSICS ENGINE & WORLD
 */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.Fog(0x87CEEB, 25, 70);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.rotation.order = 'YXZ';
const renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const loader = new THREE.TextureLoader();
const world = {};
const interactables = [];

function getMat(id) {
    const l = (url) => { const t = loader.load(url); t.magFilter = THREE.NearestFilter; return t; };
    if(id === BLOCK.GRASS) return [l(TEX.grass_side), l(TEX.grass_side), l(TEX.grass_top), l(TEX.dirt), l(TEX.grass_side), l(TEX.grass_side)].map(m => new THREE.MeshLambertMaterial({map:m}));
    if(id === BLOCK.CRAFTING) return [l(TEX.craft_side), l(TEX.craft_side), l(TEX.craft_top), l(TEX.plank), l(TEX.craft_side), l(TEX.craft_side)].map(m => new THREE.MeshLambertMaterial({map:m}));
    const t = l(ITEMS[id].texture);
    return new Array(6).fill(0).map(() => new THREE.MeshLambertMaterial({map:t}));
}

function setBlock(x, y, z, id) {
    const key = `${Math.round(x)},${Math.round(y)},${Math.round(z)}`;
    const old = scene.getObjectByName(key);
    if (old) { 
        scene.remove(old); 
        const idx = interactables.indexOf(old);
        if(idx > -1) interactables.splice(idx, 1);
        old.geometry.dispose();
        if(Array.isArray(old.material)) old.material.forEach(m => m.dispose());
        else old.material.dispose();
    }
    delete world[key];
    if (id === BLOCK.AIR) return;
    world[key] = id;
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), getMat(id));
    mesh.position.set(Math.round(x), Math.round(y), Math.round(z));
    mesh.name = key;
    scene.add(mesh);
    interactables.push(mesh);
}

function getBlockAt(x, y, z) {
    return world[`${Math.round(x)},${Math.round(y)},${Math.round(z)}`] || BLOCK.AIR;
}

const droppedItems = [];
function spawnDrop(x, y, z, id) {
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), getMat(id)[0]);
    mesh.position.set(x, y + 0.5, z);
    scene.add(mesh);
    droppedItems.push({ 
        mesh, id, 
        vel: new THREE.Vector3((Math.random()-0.5)*0.1, 0.15, (Math.random()-0.5)*0.1) 
    });
}

function generateWorld() {
    for(let x=-12; x<12; x++) {
        for(let z=-12; z<12; z++) {
            let h = Math.floor(Math.sin(x/4)*1.5 + Math.cos(z/4)*1.5);
            setBlock(x, -5, z, BLOCK.BEDROCK);
            for(let y=-4; y<h; y++) setBlock(x, y, z, y < h-2 ? BLOCK.STONE : BLOCK.DIRT);
            setBlock(x, h, z, BLOCK.GRASS);
            if(Math.random() < 0.04) {
                for(let ty=1; ty<=4; ty++) setBlock(x, h+ty, z, BLOCK.WOOD);
                for(let lx=-1; lx<=1; lx++) for(let lz=-1; lz<=1; lz++) setBlock(x+lx, h+5, z+lz, BLOCK.LEAVES);
            }
        }
    }
}
generateWorld();

/**
 * 3. PLAYER SYSTEM
 */
const player = {
    pos: new THREE.Vector3(0, 10, 0),
    vel: new THREE.Vector3(),
    onGround: false,
    health: 10,
    invincible: 0
};

function takeDamage(amt) {
    if(player.invincible > 0) return;
    player.health -= amt;
    player.invincible = 0.5;
    updateUI();
    if(player.health <= 0) respawn();
}

function respawn() {
    player.health = 10;
    player.pos.set(0, 15, 0);
    player.vel.set(0,0,0);
    updateUI();
}

/**
 * 4. CRAFTING RECIPES
 */
const RECIPES = [
    { grid: [BLOCK.WOOD], out: 6, count: 4 },
    { grid: [6, null, 6], out: 100, count: 4 },
    { grid: [6, 6, 6, 6], out: 8, count: 1 },
    { grid: [6, 6, 6, null, 100, null, null, 100], out: 101, count: 1 },
    { grid: [6, null, 6, null, 100], out: 102, count: 1 },
    { grid: [7, 7, 7, null, 100, null, null, 100], out: 103, count: 1 },
    { grid: [7, null, 7, null, 100], out: 104, count: 1 },
    { grid: [10, 10, 10, 6, 6, 6], out: 9, count: 1 }
];

const inventory = new Array(36).fill(null).map(() => ({ id: null, count: 0 }));
const craftGrid = new Array(9).fill(null);
let selectedSlot = 0;

function addToInv(id, count) {
    let s = inventory.find(x => x.id === id) || inventory.find(x => !x.id);
    if(s) { s.id = id; s.count += count; }
}

/**
 * 5. CORE LOOP & INTERACTION
 */
const keys = {};
let invOpen = false;
let mining = { block: null, progress: 0 };
const raycaster = new THREE.Raycaster();
const clock = new THREE.Clock();

document.addEventListener('keydown', e => {
    keys[e.code] = true;
    if(e.code === 'KeyE') toggleInv();
    if(e.key >= '1' && e.key <= '9') { selectedSlot = parseInt(e.key)-1; updateUI(); }
});
document.addEventListener('keyup', e => keys[e.code] = false);

function toggleInv() {
    invOpen = !invOpen;
    document.getElementById('inventory-screen').style.display = invOpen ? 'flex' : 'none';
    if(invOpen) {
        document.exitPointerLock();
        renderInvUI();
    } else {
        document.body.requestPointerLock();
        craftGrid.forEach((id, i) => { if(id) { addToInv(id, 1); craftGrid[i] = null; } });
    }
}

function stopMining() {
    mining.block = null;
    mining.progress = 0;
    document.getElementById('mining-progress-container').style.display = 'none';
    document.getElementById('mining-progress-bar').style.width = '0%';
}

document.body.addEventListener('mousedown', e => {
    if(!invOpen) document.body.requestPointerLock();
    if(invOpen || document.pointerLockElement !== document.body) return;

    raycaster.setFromCamera(new THREE.Vector2(), camera);
    const hits = raycaster.intersectObjects(interactables);
    const validHit = hits.find(h => h.distance < 5);

    if(validHit) {
        if(e.button === 0) {
            mining.block = validHit.object;
            mining.progress = 0;
            document.getElementById('mining-progress-container').style.display = 'block';
        } else if(e.button === 2) {
            const b = validHit;
            const p = b.object.position.clone().add(b.face.normal);
            const held = inventory[selectedSlot];
            if(held.id && ITEMS[held.id].type === 'block') {
                if(p.distanceTo(player.pos) > 0.8) {
                    setBlock(p.x, p.y, p.z, held.id);
                    held.count--; if(held.count <= 0) held.id = null;
                    updateUI();
                }
            }
        }
    }
});

document.body.addEventListener('mouseup', stopMining);

function updateUI() {
    const hb = document.getElementById('hotbar'); hb.innerHTML = '';
    for(let i=0; i<9; i++) {
        const s = document.createElement('div');
        s.className = 'slot' + (i === selectedSlot ? ' active' : '');
        const item = inventory[i];
        if(item.id) s.innerHTML = `<img src="${ITEMS[item.id].texture}"><span class="count">${item.count}</span>`;
        hb.appendChild(s);
    }
    const hr = document.getElementById('health-row'); hr.innerHTML = '';
    for(let i=0; i<10; i++) hr.innerHTML += `<span class="heart">${i < player.health ? '❤' : '♡'}</span>`;
}

function renderInvUI() {
    const main = document.getElementById('main-inventory'); main.innerHTML = '';
    const hot = document.getElementById('hotbar-inventory'); hot.innerHTML = '';
    const grid = document.getElementById('crafting-grid'); grid.innerHTML = '';
    for(let i=9; i<36; i++) main.appendChild(createSlot(inventory[i], i, 'inv'));
    for(let i=0; i<9; i++) hot.appendChild(createSlot(inventory[i], i, 'inv'));
    grid.style.gridTemplateColumns = 'repeat(3, 1fr)';
    for(let i=0; i<9; i++) grid.appendChild(createSlot({id: craftGrid[i], count: craftGrid[i]?1:0}, i, 'craft'));
    checkRecipes();
}

function createSlot(item, idx, type) {
    const s = document.createElement('div'); s.className = 'slot';
    if(item.id) s.innerHTML = `<img src="${ITEMS[item.id].texture}"><span class="count">${item.count > 1 ? item.count : ''}</span>`;
    s.onclick = () => {
        if(type === 'inv' && item.id) {
            for(let i=0; i<9; i++) if(!craftGrid[i]) { craftGrid[i] = item.id; item.count--; if(item.count === 0) item.id = null; break; }
        } else if(type === 'craft' && craftGrid[idx]) {
            addToInv(craftGrid[idx], 1); craftGrid[idx] = null;
        }
        renderInvUI(); updateUI();
    };
    return s;
}

function checkRecipes() {
    const res = document.getElementById('crafting-result'); res.innerHTML = '';
    const match = RECIPES.find(r => r.grid.every((id, i) => id === craftGrid[i]));
    if(match) {
        res.innerHTML = `<img src="${ITEMS[match.out].texture}"><span class="count">${match.count}</span>`;
        res.onclick = () => {
            addToInv(match.out, match.count);
            for(let i=0; i<9; i++) craftGrid[i] = null;
            renderInvUI(); updateUI();
        };
    }
}

function animate() {
    requestAnimationFrame(animate);
    const dt = Math.min(clock.getDelta(), 0.1);
    
    if(!invOpen) {
        player.vel.y -= 22 * dt;
        const yaw = camera.rotation.y;
        const dir = new THREE.Vector3();
        if(keys['KeyW']) dir.z -= 1; if(keys['KeyS']) dir.z += 1;
        if(keys['KeyA']) dir.x -= 1; if(keys['KeyD']) dir.x += 1;
        dir.applyAxisAngle(new THREE.Vector3(0,1,0), yaw).normalize().multiplyScalar(5);
        player.vel.x = dir.x; player.vel.z = dir.z;
        if(keys['Space'] && player.onGround) player.vel.y = 8, player.onGround = false;

        const next = player.pos.clone().addScaledVector(player.vel, dt);
        const isBlocked = (p) => {
            for(let x=-0.3; x<=0.3; x+=0.6) for(let y=-1.5; y<=0.2; y+=0.8) for(let z=-0.3; z<=0.3; z+=0.6) {
                if(getBlockAt(p.x+x, p.y+y, p.z+z) !== BLOCK.AIR) return true;
            }
            return false;
        };

        if(!isBlocked(new THREE.Vector3(next.x, player.pos.y, player.pos.z))) player.pos.x = next.x;
        if(!isBlocked(new THREE.Vector3(player.pos.x, player.pos.y, next.z))) player.pos.z = next.z;
        const oldY = player.pos.y;
        player.pos.y += player.vel.y * dt;
        if(isBlocked(player.pos)) {
            if(player.vel.y < -12) takeDamage(Math.floor((Math.abs(player.vel.y)-12)/2));
            player.pos.y = oldY; player.vel.y = 0; player.onGround = true;
        } else player.onGround = false;

        camera.position.copy(player.pos);
        if(player.invincible > 0) player.invincible -= dt;

        if(mining.block) {
            const blockKey = mining.block.name;
            const blockId = world[blockKey];
            if(blockId === undefined || player.pos.distanceTo(mining.block.position) > 6) {
                stopMining();
            } else {
                const data = ITEMS[blockId];
                let speed = (inventory[selectedSlot].id && ITEMS[inventory[selectedSlot].id].toolType === data.tool) ? ITEMS[inventory[selectedSlot].id].efficiency : 1;
                mining.progress += (dt / data.hardness) * speed;
                document.getElementById('mining-progress-bar').style.width = Math.min(100, mining.progress*100)+'%';
                if(mining.progress >= 1) {
                    const dropId = data.drop || blockId;
                    const pos = mining.block.position.clone();
                    spawnDrop(pos.x, pos.y, pos.z, dropId);
                    setBlock(pos.x, pos.y, pos.z, BLOCK.AIR);
                    stopMining();
                }
            }
        }
    }

    for(let i=droppedItems.length-1; i>=0; i--) {
        const d = droppedItems[i];
        if(getBlockAt(d.mesh.position.x, d.mesh.position.y - 0.25, d.mesh.position.z) === BLOCK.AIR) {
            d.vel.y -= 0.5 * dt;
            d.mesh.position.add(d.vel);
        } else {
            d.vel.y = 0;
            d.mesh.position.y = Math.round(d.mesh.position.y - 0.5) + 0.65;
        }
        d.mesh.rotation.y += 2 * dt;
        if(d.mesh.position.distanceTo(player.pos) < 1.8) {
            addToInv(d.id, 1); 
            scene.remove(d.mesh); 
            d.mesh.geometry.dispose();
            d.mesh.material.dispose();
            droppedItems.splice(i, 1); 
            updateUI();
        }
    }
    renderer.render(scene, camera);
}

const selBox = new THREE.LineSegments(
    new THREE.EdgesGeometry(new THREE.BoxGeometry(1.02, 1.02, 1.02)), 
    new THREE.LineBasicMaterial({color:0x000000, linewidth: 2})
);
selBox.raycast = () => {}; 
scene.add(selBox);

document.addEventListener('mousemove', e => {
    if(document.pointerLockElement === document.body) {
        camera.rotation.y -= e.movementX * 0.002;
        camera.rotation.x -= e.movementY * 0.002;
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
    }
    raycaster.setFromCamera(new THREE.Vector2(), camera);
    const hits = raycaster.intersectObjects(interactables);
    const validHit = hits.find(h => h.distance < 5);
    if(validHit) {
        selBox.visible = true; 
        selBox.position.copy(validHit.object.position);
    } else selBox.visible = false;
});

scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const sun = new THREE.DirectionalLight(0xffffff, 0.5); sun.position.set(10, 20, 10); scene.add(sun);
updateUI(); animate();
</script>
</body>
</html>
